/* global window */

const hasAnimation = (el) => {
  const style = window.getComputedStyle(el).transitionDuration
  const transitionDuration = style ? style.split(',') : ['0']
  return transitionDuration.reduce((prev, curr) => prev + parseFloat(curr), 0) > 0
}

const setStyle = (el, prevStyles, newStyle = '') => {
  window.requestAnimationFrame(() =>
    // prevent skipped frames and `transitionend` not firing
    el.setAttribute('style', `${prevStyles}${newStyle ? `; ${newStyle}` : ''}`),
  )
}

const getStyleUpdate = (el, update, styleFn) => {
  const newSetting = typeof update === 'function' ? update() : update
  const postFix = isNaN(newSetting) ? '' : 'px'
  return styleFn(`${newSetting}${postFix}`)
}

/* animate Factory
 *  Reason:
 *    Helper to hook into DOM Nodes that animate
 *    The node to animate should have the transition property set within css.
 *  Example:
 *    constructor(){
 *      this.animateMaxHeight = animateMaxHeight.bind(this)
 *      this.animateTransform = animateTransform.bind(this)
 *    }
 *     ...
 *     animateMaxHeight({
 *       from: 0, // int|string: Style Value to be applied before animation starts
 *       to: 100, // int|string: Style Value to be applied to start the animation
 *       persistStyles:'str', // string (optional): Style Value to persisted after animation finishes
 *       state: setStateBeforeAnimation // object: set the state before animation starts
 *     }, callBackAfterAnimation) // function: callback executed after animation ends
 */
const animate = (styleFn) =>
  function AnimateType(
    { node, from, to, state = {}, persistStyles = null, clearStyles = false, setNewStylesOnly = false },
    cb = () => {},
  ) {
    const el = node || this.animationNode
    if (!el) {
      throw Error('Please either set this.animationNode or pass in a `node` option')
    }

    const prevStyles = el.getAttribute('style') || ''
    const initialStyle = getStyleUpdate(el, from, styleFn)
    const cbWithCleanUp = () => {
      const newStyle = getStyleUpdate(el, to, styleFn)
      let style
      if (clearStyles) style = ''
      else if (setNewStylesOnly) style = newStyle
      else style = persistStyles ? `${persistStyles}; ${newStyle}` : prevStyles
      el.removeEventListener('transitionend', cbWithCleanUp, false)
      el.setAttribute('style', `${style}; transition: none;`) // prevent iOS 9 bounce i.e. do not use requestanimationframe here
      setStyle(el, style)
      cb()
    }

    const setAnimationEndStyles = () => {
      setStyle(el, prevStyles, getStyleUpdate(el, to, styleFn))
      return hasAnimation(el) ? null : cbWithCleanUp()
    }

    el.setAttribute('style', `${prevStyles}; ${initialStyle}; transition: none;`) // prevent iOS 9 bounce i.e. do not use requestanimationframe here
    el.addEventListener('transitionend', cbWithCleanUp, false)
    setStyle(el, prevStyles, initialStyle)

    this.setState(state, () => window.requestAnimationFrame(setAnimationEndStyles))
  }

const animateMaxHeight = animate((value) => `max-height: ${value}`)
const animateTransform = animate((value) => `transform: translateX(${value})`)
const animateOpacity = animate((value) => `opacity: ${value}`)

export { animate, animateMaxHeight, animateTransform, animateOpacity }
