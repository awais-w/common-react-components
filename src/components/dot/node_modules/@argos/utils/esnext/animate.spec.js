/* global jest, describe, it, expect, beforeEach, jasmine */
import React from 'react'
import Chance from 'chance'
import jsdom from 'jsdom'
import { animate } from './animate'

const chance = new Chance()
const { JSDOM } = jsdom
const transition = 'transition-duration: 250ms'
const divHtml = `<!DOCTYPE html><div style="${transition}"></div>`

let dom
let div
let style
let to
let from
let setAttribute
const setupAnimCb = ({ style, from, to, postfix = '', done, persistStyles = '', expectedCalls = 5 }) => () => {
  const finalStyle = persistStyles ? `${persistStyles}; ${style}${to}${postfix}` : `${transition}`
  setTimeout(() => {
    // wait for requestanimationframe to end
    try {
      expect(div.getAttribute('style')).toBe(
        `${finalStyle}`,
        'New Styles should be removed after animation completes, leaving only the original style',
      )
      const mockCalls = setAttribute.mock.calls
      expect(mockCalls.length).toBe(expectedCalls)
      expect(mockCalls[0][0]).toBe('style')
      expect(mockCalls[0][1]).toBe(
        `${transition}; ${style}${from}${postfix}; transition: none;`,
        'removes transition at the start to prevent a bounce on iOS',
      )
      expect(mockCalls[1][0]).toBe('style')
      expect(mockCalls[1][1]).toBe(`${transition}; ${style}${from}${postfix}`)
      expect(mockCalls[2][0]).toBe('style')
      expect(mockCalls[2][1]).toBe(
        `${finalStyle}; transition: none;`,
        'removes transition at the end to prevent a bounce on iOS',
      )
      expect(mockCalls[3][0]).toBe('style')
      expect(mockCalls[3][1]).toBe(`${transition}; ${style}${to}${postfix}`)
      expect(mockCalls[4][0]).toBe('style')
      expect(mockCalls[4][1]).toBe(`${finalStyle}`, 'removes transition:none at the end to be clean')
      done()
    } catch (e) {
      done(e)
    }
  }, 25)
}

const setupTwiceAnimCb = ({ style, from, to, postfix = '', done, persistStyles = '' }) => () => {
  const finalStyle = persistStyles ? `${persistStyles}; ${style}${from}${postfix}` : `${transition}`
  setTimeout(() => {
    // wait for requestanimationframe to end
    try {
      expect(div.getAttribute('style')).toBe(
        `${finalStyle}`,
        'New Styles should be removed after animation completes, leaving only the original style',
      )
      const mockCalls = setAttribute.mock.calls
      expect(mockCalls.length).toBe(10)

      // Check if animates correctly for first call
      setupAnimCb(style, from, to, done, 10)

      // Check if animates correctly for second call
      expect(mockCalls[5][0]).toBe('style')
      expect(mockCalls[5][1]).toBe(
        `${transition}; ${style}${to}${postfix}; transition: none;`,
        'removes transition at the start to prevent a bounce on iOS',
      )
      expect(mockCalls[6][0]).toBe('style')
      expect(mockCalls[6][1]).toBe(`${transition}; ${style}${to}${postfix}`)
      expect(mockCalls[7][0]).toBe('style')
      expect(mockCalls[7][1]).toBe(
        `${finalStyle}; transition: none;`,
        'removes transition at the end to prevent a bounce on iOS',
      )
      expect(mockCalls[8][0]).toBe('style')
      expect(mockCalls[8][1]).toBe(`${transition}; ${style}${from}${postfix}`)
      expect(mockCalls[9][0]).toBe('style')
      expect(mockCalls[9][1]).toBe(`${finalStyle}`, 'removes transition:none at the end to be clean')
      done()
    } catch (e) {
      done(e)
    }
  }, 25)
}

jasmine.DEFAULT_TIMEOUT_INTERVAL = 5000

describe('Animate Factory', () => {
  beforeEach(() => {
    dom = new JSDOM(divHtml)
    div = dom.window.document.querySelector('div')
    const oldSetAttribute = div.setAttribute.bind(div)
    setAttribute = jest.fn((props, value) => {
      oldSetAttribute(props, value)
    })
    div.setAttribute = setAttribute
  })

  it('should set given styles at start and end of animation', (done) => {
    style = 'max-height: '
    from = 0
    to = 100

    const refToAnimate = div
    const setStateBeforeAnimation = { random: chance.integer() }
    const callBackAfterAnimation = setupAnimCb({
      style,
      from,
      to,
      postfix: 'px',
      done,
    })

    const ctx = {
      setState: (args, cb) => {
        try {
          expect(div.getAttribute('style')).toBe(
            `${transition}; max-height: 0px; transition: none;`,
            'Style should be added ready for animation',
          )
          expect(args).toEqual(setStateBeforeAnimation, 'Arguments should be passed to the setState function')
          cb()
        } catch (e) {
          done(e)
        }
      },
    }

    const animateMaxHeight = animate((value) => `${style}${value}`).bind(ctx)
    animateMaxHeight({ node: refToAnimate, from, to, state: setStateBeforeAnimation }, callBackAfterAnimation)
    done()
  })

  it('should px if no measurements given', (done) => {
    style = 'max-height: '
    from = 0
    to = 100

    const refToAnimate = div
    const setStateBeforeAnimation = { random: chance.integer() }
    const callBackAfterAnimation = setupAnimCb({
      style,
      from,
      to,
      postfix: 'px',
      done,
    })

    const ctx = {
      setState: (args, cb) => {
        try {
          expect(div.getAttribute('style')).toBe(
            `${transition}; max-height: 0px; transition: none;`,
            'Style should be added ready for animation',
          )
          expect(args).toEqual(setStateBeforeAnimation, 'Arguments should be passed to the setState function')
          cb()
        } catch (e) {
          done(e)
        }
      },
    }

    const animateMaxHeight = animate((value) => `${style}${value}`).bind(ctx)
    animateMaxHeight({ node: refToAnimate, from, to, state: setStateBeforeAnimation }, callBackAfterAnimation)
    done()
  })

  it('should persist measurements given', (done) => {
    style = 'max-height: '
    from = '0vh'
    to = '100vh'

    const refToAnimate = div
    const setStateBeforeAnimation = { random: chance.integer() }
    const callBackAfterAnimation = setupAnimCb({ style, from, to, done })

    const ctx = {
      setState: (args, cb) => {
        try {
          expect(div.getAttribute('style')).toBe(
            `${transition}; max-height: 0vh; transition: none;`,
            'Style should be added ready for animation',
          )
          expect(args).toEqual(setStateBeforeAnimation, 'Arguments should be passed to the setState function')
          cb()
        } catch (e) {
          done(e)
        }
      },
    }

    const animateMaxHeight = animate((value) => `${style}${value}`).bind(ctx)
    animateMaxHeight({ node: refToAnimate, from, to, state: setStateBeforeAnimation }, callBackAfterAnimation)
    done()
  })

  it('works with implicate node to animate (this.animationNode)', (done) => {
    style = 'max-height: '
    from = '0vh'
    to = '100vh'

    const refToAnimate = div
    const setStateBeforeAnimation = { random: chance.integer() }
    const callBackAfterAnimation = setupAnimCb({ style, from, to, done })

    const ctx = {
      animationNode: refToAnimate,
      setState: (args, cb) => {
        try {
          expect(div.getAttribute('style')).toBe(
            `${transition}; max-height: 0vh; transition: none;`,
            'Style should be added ready for animation',
          )
          expect(args).toEqual(setStateBeforeAnimation, 'Arguments should be passed to the setState function')
          cb()
        } catch (e) {
          done(e)
        }
      },
    }

    const animateMaxHeight = animate((value) => `${style}${value}`).bind(ctx)
    animateMaxHeight({ from, to, state: setStateBeforeAnimation }, callBackAfterAnimation)
    done()
  })

  it('animates twice and should not double up on styles', (done) => {
    style = 'max-height: '
    from = '0vh'
    to = '100vh'

    const refToAnimate = div
    const setStateBeforeAnimation = { random: chance.integer() }
    const callBackAfterAnimation = setupTwiceAnimCb({ style, from, to, done })

    const ctx = {
      animationNode: refToAnimate,
      setState: (args, cb) => {
        try {
          expect(div.getAttribute('style')).toContain(
            `${transition}; max-height: 0vh; transition: none;`,
            'Style should be added ready for animation',
          )
          expect(args).toEqual(setStateBeforeAnimation, 'Arguments should be passed to the setState function')
          cb()
        } catch (e) {
          done(e)
        }
      },
    }
    const ctx2 = {
      animationNode: refToAnimate,
      setState: (args, cb) => {
        try {
          expect(div.getAttribute('style')).toContain(
            `${transition}; max-height: 100vh; transition: none;`,
            'Style should be added ready for animation',
          )
          expect(args).toEqual(setStateBeforeAnimation, 'Arguments should be passed to the setState function')
          cb()
        } catch (e) {
          done(e)
        }
      },
    }

    const animateMaxHeight = animate((value) => `${style}${value}`).bind(ctx)
    const animateMaxHeight2 = animate((value) => `${style}${value}`).bind(ctx2)
    animateMaxHeight({ from, to, state: setStateBeforeAnimation }, () => {
      setTimeout(
        () => animateMaxHeight2({ from: to, to: from, state: setStateBeforeAnimation }, callBackAfterAnimation),
        5,
      )
    })
    done()
  })

  it('animates and persists styles', (done) => {
    style = 'max-height: '
    from = 0
    to = 100
    const persistStyles = 'max-width: 50vh'
    const refToAnimate = div
    const setStateBeforeAnimation = { random: chance.integer() }
    const callBackAfterAnimation = setupAnimCb({
      style,
      from,
      to,
      postfix: 'px',
      done,
      persistStyles,
    })

    const ctx = {
      setState: (args, cb) => {
        try {
          expect(div.getAttribute('style')).toBe(
            `${transition}; max-height: 0px; transition: none;`,
            'Style should be added ready for animation',
          )
          expect(args).toEqual(setStateBeforeAnimation, 'Arguments should be passed to the setState function')
          cb()
        } catch (e) {
          done(e)
        }
      },
    }

    const animateMaxHeight = animate((value) => `${style}${value}`).bind(ctx)
    animateMaxHeight(
      {
        node: refToAnimate,
        from,
        to,
        state: setStateBeforeAnimation,
        persistStyles,
      },
      callBackAfterAnimation,
    )
    done()
  })
})
